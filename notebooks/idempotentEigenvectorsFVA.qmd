---
Author: "FVA"
Title: "Idempotent Eigenvectors"
Date: "2023-10-01"
engine: julia
julia:
  exeflags: ["--project=.."]
theme:
    light: flatly
    dark: darkly
---

# Intro

This notebook exemplifies the construction of transitive closures of matrices over the completed max-plus semifield in terms of the Upper Frobenius Normal Forms (UFNF).

The theory behind these constructions can be found in two papers and their references:

1. F. J. Valverde-Albacete and C. Peláez-Moreno, “The spectra of irreducible matrices over completed idempotent semifields,” Fuzzy Sets and Systems, vol. 271, pp. 46–69, July 2015, doi: 10.1016/j.fss.2014.09.022.

2. F. J. Valverde-Albacete and C. Peláez-Moreno, “The spectra of reducible matrices over complete commutative idempotent semifields and their spectral lattices,” Int J Gen Syst, vol. 45, no. 2, pp. 86–115, Feb. 2016, doi: 10.1080/03081079.2015.1072923.

TODO: transform this into a package or extend LinearAlgebra with a script for the eigenproblem of the max-plus semifield. 

# Environment Construction

```{julia}
using DrWatson
DrWatson.quickactivate(@__DIR__)
#@quickactivate(@__DIR__)
#using Pkg; Pkg.add("CSV")
using DataFrames, CSV
using Graphs
#using Semifields
using SparseArrays
using MaxPlus
using Printf
```

Now define attributes for the environment:
```{julia}
set_tropical_display(1)#Q:FVA: where does this primitive come from?
Base.show(io::IO, ::MIME"text/latex", x::MP) = show(io, MIME"text/plain", x)
Base.show(io::IO, ::MIME"text/latex", A::MPAbstractVecOrMat) = show(io, MIME"text/plain", A)
```

Fix the random seed:

```{julia}
using Random
seed_value = 17
Random.seed!(seed_value)
```

A general tolerance values:

```{julia}
tol = 1e-10#Should also be used for comparisons in function `is approx`.
```

## Construction primitives

### Basic matrices

These matrices are used time and again:

```{julia}
using MaxPlus
#using LinearAlgebra
"""
Maxplus identity

"""
function I(n::Int, m::Int)::Matrix{MP}
    #(n > 0 && m > 0)  || error("Can only generate n,m >= 1 matrices")   
    return MP([(i != j ? -Inf : 0.0) for i in 1:n, j in 1:m])#this is In, but we Avoid allocating extra
    #return Matrix{MP}(MaxPlus.I, n, m)#FVA: from the documentation on constructions
    #return eye(MP,n,m)
end 
#LinearAlgebra.I(n) = I(n,m)
I(n) = I(n,n)

"""
Maxplus bottom matrix of order `n x m`. With single parameter the square matrix is created.
"""
function nB(n::Int, m::Int)
    #(n > 0 && m > 0) ||  error("Can only generate n,m >= 1 matrices")   
    return fill(ε, (n,m))#FVA: from the documentation on constructions varepsilon = ε is the bottom
    
end
nB(n::Int) = nB(n,n)

"""
Maxplus top matrix of order `n x m`. With single parameter the square matrix is created.
"""
function nT(n::Int, m::Int)
    #(n > 0 && m > 0) ||  error("Can only generate n,m >= 1 matrices")   
    return fill(mptop,(n,m))#FVA: from the documentation on constructions, mptop is Inf
end
nT(n::Int) = nT(n,n)
```

Testing for approximation we need to extend Base.isapprox

```{julia}
dist = 1e-10
Base.isapprox(a::MP, b::MP) = 
    isapprox(plustimes(a) .+ dist, plustimes(b) .+ dist)
a = Tropical{MaxPlus.Max}(5.0)
b = Tropical{MaxPlus.Max}(5.0 + 1e-10)
@assert a ≈ b
#Base.isapprox(A::Matrix{MP}, B::Matrix{MP}) = all(plustimes(A) .+ dist .≈ plustimes(B) .+ dist)
Base.isapprox(A::Matrix{MP}, B::Matrix{MP}) = plustimes(A) .+ dist ≈ plustimes(B) .+ dist#Not the poinwise comparison
#A = MP(M1)
#@assert A  ≈ A .* MP(dist)#THis is a failure of approximation. Check Semifields package.
```
## Data 
### Example data 1

A simple two-scc example in UFNF2 to obtain the eigenvectors supplied by ERFs: 

```{julia}
M2 = [
    0.0  1.0  -Inf -Inf -Inf;
   -Inf 0.0  2.0  -Inf -Inf;
    1.0 -Inf 0.0  -Inf -Inf;
   -Inf -Inf -Inf 0.0 1.0;
   -Inf -Inf -Inf -Inf 0.0
]
A2 = MP(M2)
```
This matrix is in UFNF2.

This has two strongly connected components:
  * [[1,2,3]]: 
    *  single irreducible component by cycle: 1 -> 2 -> 3 -> 1 lambda = 4/3
  * [[4], [5]]: t
    * two irreducible scc: 5 -> 5: lambda = 0, 4 -> 4: lambda = 0.0
    * Condensation digraph [4] -> [5] So, 5 is shadowed, but has the same lambda as the original. 

This has two distinct and orthogonal eigenspaces in coords [1,2,3] and [4,5]
  * the first one is a total order of ingfinite length generated by any of v_1, v_2, or v_3 which are also linearly ordered. 
  * the second one is also a total order of length 2: ev_4 < ev_5 
So the whole space is a product of two orders.

We obfuscate the structure to validate :
```{julia}
using Permutations#Check for interface at: https://juliapackages.com/p/permutations
p2 = RandomPermutation(size(M2,1))#keep everything contained there
A2obfuscated = MP(M2[p2.data, p2.data])
```

We extract a matrix in UFNF0 (irreducible) for tests:
```{julia}
M0 = M2[1:3,1:3]
A0 = MP(M0)
```
There is really no need for obfuscation of irreducible matrices. 


### Example data 2 from Akian, Bapat, Gaubert, 2015. Chapter 25: Max-plus Algebra

This is a reducible matrix in UFNF1 with a single connected component and shadowed classes:

```{julia}
M1 = fill(-Inf, (8,8))
M1[1,1:8] = [0 -Inf 0 -Inf 7 -Inf -Inf -Inf]
M1[2:4, 2:4] = [-Inf 3 0; 1 -Inf -Inf; 2 -Inf -Inf]
M1[4,8] = 10
M1[5:7, 5:7] = [1 0 -Inf; -Inf -Inf 0; -1 2 -Inf]
M1[7,8] = 23
M1[8,8] = -3
A1 = MP(M1)
```
Permute rows and columns to obfuscate the UFNF2

```{julia}
#using Permutations#Check for interface at: https://juliapackages.com/p/permutations
p1 = RandomPermutation(size(M1,1))#keep everything contained there
A1obfuscated = MP(M1[p1.data, p1.data])
```

### Example 3: A matrix in UFNF2 proper

```{julia}
n1 = size(M1,1)
n2 = size(M2,1)
M3 = fill(-Inf, (n1 + n2, n1 + n2))#also nB(n1+n2)
M3[1:n1, 1:n1] = M1
M3[n1 .+ (1:n2), n1 .+ (1:n2)] = M2
A3 = MP(M3)#Three block diagnonal components => a product space of three dimensions!
```

An obfuscated version:

```{julia}
#using Permutations#Check for interface at: https://juliapackages.com/p/permutations
p3 = RandomPermutation(size(M3,1))#keep everything contained there
A3obfuscated = MP(M3[p3.data, p3.data])
```
### Example 3: A matrix that properly accepts UFNF3 form

```{julia}
# Two empty rows and columns, 1 empty col and 3 empty rows 
n_ι = 2#both empty rows and cols
n_α = 3#only empty cols
n_β = size(M3,1)
n_ω = 1#only empty rows 
#n = n_ι + n_α + n_β + n_ω
M4 = fill(-Inf, (n_ι + n_α + n_β + n_ω, n_ι + n_α + n_β + n_ω))
M4[ (n_ι + n_α) .+ (1:n_β),(n_ι + n_α) .+ (1:n_β)] = M3#Two empty rows, Three empty cols at the beginning, prior to M3
#M4[(2 + 1 + n1) .+ (1:n2), (2 + n1) .+ (1:n2)] = M2#1 empty line prior to 
M4[n_ι .+ (1:n_α), n_ι + n_α .+ (1:(n_β + n_ω))] = rand(vcat([-Inf, -Inf, -Inf], collect(0:4)), n_α, n_β + n_ω)# Random generation of isolated links. Unrefined and inelegant.
M4[(n_ι + n_α) .+ (1:n_β), (n_ι + n_α + n_β) .+ (1:n_ω)] = rand(vcat([-Inf, -Inf, -Inf], collect(0:4)), n_β, n_ω)
A4 = MP(M4)
```

An obfuscated version:

```{julia}
#using Permutations#Check for interface at: https://juliapackages.com/p/permutations
p4 = RandomPermutation(size(M4,1))#keep everything contained there
A4obfuscated = MP(M4[p4.data, p4.data])
```

### Basic operation: matrix powers

```{julia}
"""
    mmp_mpower_raw(A::Matrix{MP}, k::Int64; n = size(A,1)) → Matrix{MP}

Fast MP-exponentiation of matrices.
Preconditions (untested): size(A,1) == size(A, 2), k >= 0

This uses the using the doubling approach. 
"""
function mmp_mpower_raw(A::Matrix{MP}, k::Int64; n = size(A,1))
     # PReconditions: size(A,1) == size(A, 2), k >= 0
    k == 1 && return A#early termination
    k == 0 && return [MP(i != j ? -Inf : 0.0) for i in 1:n, j in 1:n]#this is In, but we Avoid allocating extra
    Y = [MP(i != j ? -Inf : 0.0) for i in 1:n, j in 1:n]
    #Here n > 1
    #Here we have: #Y = I_n#in the first pass
    while k > 0
        if isodd(n)
            Y = Y * A 
        end 
        A = A * A
        k >>= 1#Bitwise division by 2
    end
    return Y#when k==0 it returns just Y = I(n), when k==1 it would pass through exactly once.
end
```

```{julia}
mmp_mpower_raw(A0, 20; n = 3)
mmp_mpower_raw(A0, typemax(Int64); n = 3) #.>= typemax(Float64)
```
```{julia}
"""
    mmp_mpower(A::Matrix{MP}, k::Int) → Matrix{MP}

A function to work out the `k`-th MP power of matrix `A` by the power doubling method.

This function is the basis for the closures so it needs to be extremely efficient.

Parameters
  * `A` the square matrix to be exponentiated
  * `k` the non-negative exponent 

Result: `A^k`

#Example:
"""
function mmp_mpower(A::Matrix{MP}, k::Int64)
    m,n = size(A)
    m == n || error("Can only find k-th power on a square matrix.")
    k >= 0 || error("Can only do positive powers by this method.")
    return mmp_mpower_raw(A, k; n = n)
end

```

Some tests:

```{julia}
#A = MP(M1)
#mmp_mpower(A0, -1)#error
mmp_mpower(A0,20)
```

```{julia}
"""

    rclosure(A::Matrix{T}) where T <: Number → Matrix{T}

Cheap reflexive closure.

TODO: mark it as a macro 
"""
function rclosure(A::Matrix{T}) where T <: Number
    (m,n) = size(A)
    for i in 1:min(n,m) 
        #A[i,i] = A[i,i] + one(T)#FVA: not true of most semirings
        A[i,i] = max(A[i,i], one(T))#FVA: might be more generic
    end
    return A
end
```

# FVA's approach

## Plain UFNF

TODO: In keeping synch with `LinearAlgebra.jl` as much as possible, to build a special factorization, eg. LU (q.v.) the primitive is the all-lowervase name of the factorization e.g. "lu". So for any UFNFX it should be ufnfX, with X being the factorization. For this purpose, UFNF3 i just UFNF!

For the max- or min-plus factorizations this is crucial for the spectral decomposition. After this we can actually work out the proper spectrum or the eigenvectors.

These factorizations are always related to a matrix, and the inductive scheme comes from 2, lemma 2.13.

```{julia}
using LinearAlgebra#: Factorization
"""
    UFNF - Upper Frobenius Normal Form

A new type of matrix factorization that manifests the cycle structure of the matrix, which is must for 
eigendecompositions of ver semifields.
"""
abstract type UFNF{T <: Number} #<: Factorization end#FVA:how can this type be final if it is subtyped so many times in LA?
end
```

## Finding the UFNF form

Introduce cycles:

```{julia}
"""
    Cycle == Array{Int}
A type alias for cycles of indices of a matrix (they wrap up)
"""
Cycle = Array{Int}
#Some helper functions
#TODO: inline them


"""
    cycle2pairs(cc) → Array{Tuple{Int, Int}}

A function to transform a cycle in a graph into the list of pairs of the associated adjacency matrix.
This is useful for latter obtaining the weights of the edges in the path.

Parameters:
- cc::Array{Int}
"""
cycle2pairs(cc) = length(cc) == 1 ? (cc[1], cc[1]) : zip(cc, [cc[2:end]; cc[1]])

"""

    weight(A::Matrix{T}, cc::Cycle) → T
    A function to find the weight of a cycle wrt a matrix. 
"""
weight(A::Matrix{T}, cc::Cycle)::T = 
            reduce(*, A[CartesianIndex.(cycle2pairs(cc))]; init=one(T))       
```

### UFNF0: The base case for irreducible matrices

A primitive type to deal with the base case. 

```{julia}
"""
    UFNF0{T <: Number} <: UFNF{T}

A compound implementation of the UFNF form for irreducible matrices: 
only the critical cycle structure is maintained.
"""
@kwdef struct UFNF0{T <: Number} <: UFNF{T}
    λ::T#The average length of a critical cycle
    # c: indexes into the critical cycles of the matrix.
    nodes::Array{Int}#List of nodes in the matrix.
    cycles::Array{Cycle}#list of critical cycles
    #UFNF0{T}(n::Int,cycles) where {T<:Number} = new(1:n, cycles)
end

#Base.show(io::IO, ::MIME"text/latex", x::UFNF{MP}) = show(io, MIME"text/plain", x)

"""
    ufnf₀(A::Matrix{T <: Number}) → UFNF0{T}

A function to obtain the UFNF0 form of a matrix.

Preconditions A is square and irreducible. 
"""
function ufnf₀(A::Matrix{T}) where  T <: Number
    (n,m) = size(A)
    @assert n == m && n != 0 "Can only do UFNF0 for non-zero dimension square matrices."
    #n == m || n == 0 || error("Can only do UFNF0 for non-zero dimension square matrices.")
    dg = Graphs.DiGraph(A  .!= zero(T))
    allCycles::Array{Cycle} = Graphs.simplecycles_hawick_james(dg)
    #avrgeCycleWeight = [weight(A,cc)^(1/length(cc))  for cc in allCycles]
    avrgeCycleWeight = [length(cc) == 1 ? 
            A[cc[1], cc[1]] : weight(A,cc)^(1/length(cc)) 
            for (c,cc) in enumerate(allCycles)]
    λ = maximum(avrgeCycleWeight)#The λ is maximum cycle mean
    #The critical cycles are those whose cycle mean is the λ
    cc::Array{Cycle} = allCycles[avrgeCycleWeight .≈ λ]
    return UFNF0{T}(λ,collect(1:n),cc)
end
```


```{julia}
#ufnf₀([0;;])#should error
#ufnf₀([0.0;;])#should error
#ufnf₀([MP(0.0);;])#should error
#typical results
T = MP
A = A0
cc = [1,2,3]
#thisufnf0 = UFNF0{MP}(cc)
thisufnf0 = ufnf₀(A0)#Comparison of structures not available!
fieldnames(typeof(thisufnf0))
(;λ, nodes, cycles) = thisufnf0
@assert λ  ≈ MP(1.33333333333333) && length(cycles) == 1 && length(cycles[1]) == 3
```

### Properly reducible matrices

```{julia}
"""
A struct describing the result of analysing a matrix in UFNF1 (reducible).
- lambdas: list of critical cycle means for the irreducible components.
- sccs::Array{Array{Int}} list of strongly connected components.
- cycles::Array{Array{Cycle}} list of critical cycles per component
    in `cycles[s][c]`
    s: indexes into the strongly connected components.
    c: indexes into the critical cycles of the matrix.
- cdg::SimpleDiGraph{Int} condensation digraph for the 
"""
@kwdef struct UFNF1{T <: Number} <: UFNF{T}
    #lambdas::Array{T}#The average length of a critical cycle
    sccs::Array{Array{Int}}#list of strongly connected components.
    cdg::SimpleDiGraph{Int}
    #cycles::Array{Array{Cycle}}#list of cycles for each strongly connected comp. 
    ufnf0s::Array{UFNF0{T}}#list of UFNF0s for irreducible components.
    UFNF1{T}(sccs,cdg,u) where {T<:Number} = new(sccs,cdg,u)
end
```

These accept an UFNF1 form:

```{julia}
"""
    ufnf₁_raw(Aᵣ::Matrix{MP}, n::Int)

An auxiliary function to carry out 
"""
function ufnf₁_raw(Aᵣ::Matrix{T}, n::Int) where  T <: Number
    #n = size(Aᵣ)
    #dg = Graphs.DiGraph(Aᵣ .!= MP(-Inf))#Make this generic in semiring
    dg = Graphs.DiGraph(Aᵣ .!= zero(T))#
    sccs = strongly_connected_components(dg)#Find the sccs of dg...
    cdg = Graphs.condensation(dg, sccs)# ...and their condensation digraph.

    # Finding the UFNF1 form
    nsccs = length(sccs)#number of scc of cc of index s
    if nsccs != 1
        order = topological_sort_by_dfs(cdg)
        sccs = sccs[order]#Reordering in topological order produces UFN1 for this matrix!
        #reorderedNodes = reduce(vcat,sccs)
        #Reordering only in this case.
        #Aᵣ = Aᵣ[reorderedNodes, reorderedNodes]#Biggest mat to deal
    end

    #lambdas = Array{MP}(undef, nsccs)#Make room for eigenvalues
    #Astars = Array{Matrix{MP}}(undef, nsccs)#Make room for stars
    #cycles = Array{Array{Cycle}}(undef, nsccs)#Make room for eivenvector indices. 
    ufnf0s = Array{UFNF0{T}}(undef, nsccs)
    for s in 1:nsccs
        nodes = sccs[s]#Nodes are local to this component
        #ufnf0s[s] = UFNF0{T}(nodes)#Store for later use.
        ufnf0s[s] = ufnf₀(Aᵣ[nodes,nodes])
        #lambdas[s] = ufnf0s[s].λ
        #lambdas[s], distalCycles = getUFNF₀(Aᵣ[nodes, nodes]; tol=tol)
        #cycles[s] = map(dCycle -> nodes[dCycle],ufnf0s[s].cycles)
    end
    #return UFNF1{MP}(lambdas, sccs, cdg, cycles, ufnf0s)
    return UFNF1{T}(sccs, cdg, ufnf0s)
    #return lambdas, evNodes, sccs, cdg  #, levs, revs
end

"""
    ufnf₁(Aᵣ::Matrix{MP}) → 

Find the UtMV of a matrix that is weakly connected but reducible and find its UFNF1 form. 

Precondition:
    - only for square matrices of dimension > 0
    - no empty rows or columns, e.g. already done UFNF2 analysis, block diagonal form.

TODO: Change the return order below into a `PreEigen <: Factorization` structure that resembles what LinearAlgebra.jl does. This would be used by eigvals and eigvecs to obtain one and the other, perhaps transforming into an `Eigen <: Factorization` for MP and in general for Semifields.  

Returns (in this order): 
- `λᵢ`: the single eigenvalue for this matrix
- `evNodes`: a vector of vectors coindexed with sccs of eigennodes where left and right eigenvectors are realised. 
- `sccs`: the strongly connected components of the weakly connected reducible matrix.
- `dcg`: condensation digraph of the reducible component. 

"""
function ufnf₁(Aᵣ::Matrix{T}) where T <: Number
    (n,m) = size(Aᵣ)
    @assert n == m && n != 0  "Can only do UtMV1 for non-zero dimension square matrices."
    return ufnf₁_raw(Aᵣ,n)
end
```

Observing the strongly connected components and their digraphs:

```{julia}
Aᵣ = A1obfuscated#From Akian, Bapat, Gaubert 2015
thisUfnf1 = ufnf₁(Aᵣ)
(; sccs, cdg, ufnf0s) = thisUfnf1
using GraphPlot
#p = graphplot(dg, ilabels=collect(vertices(dg)))
nodelabel = collect(vertices(cdg))
gplot(cdg; 
    nodelabel=sccs,
    title="condensation digraph of A1obfuscated")
sccs
ufnf0s[2]
```


### Properly block diagonal matrices in UFNF2 form

TODO: Pass the already found graphs to the recursive descent cascade!

```{julia}
"""
A struct describing the result of analysing a matrix in UFNF1 (reducible).
- lambdas: list of critical cycle mean lists. Coindexed with wccs
- wccs::Array{Array{Array{Int}}} list of weakly connected components.
    each wccs[w] is a list of strongly connected components.
- cycles::Array{Array{Array{Cycle}}} list of critical cycles per component
    in `cycles[w][s][c]`
    w: indexes into the weakly connected components.
    s: indexes into the strongly connected components.
    c: indexes into the critical cycles of the matrix.
- cdg::Array{SimpleDiGraph{Int}} condensation digraphs for the wccs
- ufnf1s::Array{UFNF1{T}}: list of UFNF1 of the wccs
"""
@kwdef struct UFNF2{T <: Number}  <: UFNF{T}
    #lambdas::Array{Array{T}}#The average length of a critical cycle
    wccs::Array{Array{Array{Int}}}#list of weakly connected components.
    cdg::Array{SimpleDiGraph{Int}}#condensation digraph
    #cycles::Array{Array{Array{Cycle}}}#list of cycles for each strongly connected comp. 
    ufnf1s::Array{UFNF1{T}}#list of UFNF0s for irreducible components.
    UFNF2{T}(wccs,cdg,u) where {T<:Number} = new(wccs,cdg,u)
end
```
```{julia}
"""
    ufnf₂_raw(Ad::Matrix{T}) where T <: Number → UFNF2{T}

"""
function ufnf₂_raw(Ad::Matrix{T}) where T <: Number
    # Find the weakly connected components
    dg = Graphs.DiGraph(Ad .!= zero(T))
    blocks = weakly_connected_components(dg)#In any order

    #but it is nice to order them in increasing number of nodes per component, to make the UFNF "stable by the base"
    sort!(blocks; by=length)#here we used the in-sort type of sorting, since the inportant info is the node identities.

    # UFNF2 diagonal of UFNF1
    nwccs = length(blocks)#number of weakly connected components
    #All the following vectors are coindexed with ccs
    #lambdas = Array{Array{MP}}(undef, nwccs)#Make room for eigenvalues
    #cycles = Array{Array{Array{Cycle}}}(undef, nwccs)#critical cycles
    wccs = Array{Array{Array{Int}}}(undef, nwccs)#UFNF ordered list of weakly connected components. 
    cdg = Array{SimpleDiGraph{Int}}(undef,nwccs)#Condensation digraphs of  weakly connected components
    ufnf1s = Array{UFNF1{MP}}(undef,nwccs)
    for w in 1:nwccs#go over each connected component
        block = blocks[w]
        #caveat: the node numbers below are relative to those in cc (1st level of indirection)
        println("Finding UFNF1 for weakly cc:", block)
        #the cdgs are coindexed with the sccs!
        ufnf1s[w] = ufnf₁_raw(Ad[block,block], length(block))
        #FVA: Traslate nodes!
        #lambdas[w] = ufnf1s[w].lambdas
        wccs[w] = map(dSccs -> block[dSccs], ufnf1s[w].sccs)
        #cycles[w] = map(dSccs -> map(cycle -> block[cycle], dSccs),
        #            ufnf1s[w].cycles)
        cdg[w] = ufnf1s[w].cdg
            
        #distalNodes = reduce(vcat,distalEvNodes)#This is th
        #onodes = nodes[distalNodes]
        #Ad[onodes,onodes]
        #evnodes[w] = map(distalCcs -> nodes[distalCcs], distalEvNodes)
        #sccs[w] = map(distalCcs -> nodes[distalCcs], distalSccs)
        #@assert evs are ok here
    end
#   return UFNF2{MP}(lambdas,wccs,cdg,cycles,ufnf1s)
    return UFNF2{T}(wccs,cdg,ufnf1s)
    #return lambdas, evnodes, sccs, cdg
end

"""
    ufnf₂(Ad::Matrix{T}) where T <: Number → UFNF2{T}

"""
function ufnf₂(Ad::Matrix{T}) where T <: Number 
    (n,m) = size(Ad)
    n == m || n == 0 | error("Can only do UtMV2 for non-zero dimension square matrices.")
    return ufnf₂_raw(Ad)
end
```

```{julia}
Ad = A3obfuscated#FVA: entry point for parameter of the algorithm
thisUfnf2 = ufnf₂(Ad)
neworder = reduce(vcat,reduce(vcat,thisUfnf2.wccs))#Reordering of the nodes for an UFNF2
Ad[neworder,neworder]#This is isomorphic to A3
```

### Generic matrices in UFNF3

If A has zero lines it can be transformed by a simultaneous row and column permutation of V A into UFNF₃ as per (5):

First a structure for UFNFs:
```{julia} 
"""
This structure relates to a matrix `A` of any type of number, that is to say, it is combinatorial. 

Once the structure exists for matrix, it can be simultaneously row and column-permuted into UFNF3. 
"""
@kwdef struct UFNF3{T <: Number}  <: UFNF{T}
    #lambda::Array{Union{T,Nothing}}#length 2: first is ε as a left eigenvalue
    iota::Vector{Int}#indices of empty rows and cols
    alpha::Vector{Int}#indices of empty cols but not rows
    beta::Vector{Int}#indices of non-empty cols and rows
    omega::Vector{Int}#indices of empty rows but not cols
    # if beta is not empty then the matrix A[beta, beta] accepts 
    # and UFNF2, essentially a block diagonal matrix. 
    ufnf2::Union{UFNF2{T}, Nothing}#nothing marks UFNF2 of empty matrices
    UFNF3{T}(i,a,b,o,u) where {T <: Number} = new(i,a,b,o,u)
end
#Outer constructor for empty matrices
function UFNF3{T}(i,a,b,o) where {T <: Number}
    return UFNF3{T}(i,a,b,o,nothing)
end
```

```{julia}
"""
    ufnf₃(A::Matrix{T}) where T <: Matrix → UFNF3{T}

A function to obtain the left and right Eigen factorization of a generic matrix by means of obtaining its Upper Frobenius Normal Form. 

The block structure detects what UFNF type the matrix is in:
- if the first block is not empty then the form is UFNF1
- if it has more than two blocks then the form is UFNF2, block diagonal
- if it has a first empty block and the second block is not unitary it is UFNF1, reducible
- if it has a first empty block and the second block is unitary, it is UFNF0, irreducible.
To find the UFNF form of the matrix.
Example:
'''julia
iota = allZeroCols ∩ allZeroRows#Generating the space
alpha = setdiff(allZeroCols, iota)
omega = setdiff(allZeroRows, iota)
beta = setdiff(1:n, allZeroCols ∪ allZeroRows)
reorder = vcat(iota,alpha,betareordered,omega)
A[reorder,reorder]#is almost in UFNF3 form, except for beta
#lambdas, levnodes, revnodes, blocks, cdgs = getUFNF₃(A[beta,beta]) 
#betareordered = reduce(vcat, reduce(vcat,blocks))
''
"""
function ufnf₃(A::Matrix{T}) where T <: Number
    (n,m) = size(A)
    n == m || error("UFNF3 only applicable to square matrices")#strictly not true
    allZeroCols = collect(1:n)[all(A .== zero(T), dims=1)']
    #Early termination for empty matrices generating boolean spectral lattices for ε
    #length(allZeroCols) == n && return UFNF3{MP}([ε,ε],allZeroCols,[],[],[])
    length(allZeroCols) == n && return UFNF3{T}(allZeroCols,[],[],[])
        #return UFNF3{MP}([[ε],[ε]],allZeroCols, [], [], [])
        #return UFNF3{MP}(;lambdas=[[ε],[ε]], 
        #iota=allZeroCols, alpha=[], beta=[], omega = [], ufnf2=nothing)
    #Otherwise, limit the zero spectral semivector space to empty cols and rows
    allZeroRows = collect(1:n)[all(A .== zero(T), dims=2)]
    #lambda::Array{Union{MP,Nothing}} = 
    #    [isempty(allZeroRows) ? nothing : ε,
    #     isempty(allZeroCols) ? nothing : ε]
    # Decompose the indices into empty row and cols, etc. (Related to names in paper) 
    iota = allZeroCols ∩ allZeroRows#Empty rows and cols. See alpha and omega below.
    beta = setdiff(1:n, allZeroCols ∪ allZeroRows)# Nonempty rows and cols. 
    #obtain the UFNF2 de beta, *in the distal nodes*
    ufnf2 = ufnf₂_raw(A[beta,beta])

    #traslate distalEvnodes and distalSCCS
    #evnodes = map(distalCcs -> 
    #                map(distalSccs -> beta[distalSccs], distalCcs), distalEvnodes)
    #reorderblocks = map(distalCcs -> 
    #                map(distalSccs -> beta[distalSccs], distalCcs), ufnf2.wccs)#no longer sccs
    betareordered = 
        reduce(vcat, 
            mapreduce(
                distalCcs -> map(distalSccs -> beta[distalSccs], distalCcs),
                vcat, 
                ufnf2.wccs
            )
        )
    @assert Set(beta) == Set(betareordered)
    return UFNF3{T}(; iota, 
                        alpha = setdiff(allZeroCols, iota),#Empty-cols, non-empty rows indices
                        beta=betareordered, 
                        omega = setdiff(allZeroRows, iota),#Empty-rows, non-empty colss indices
                        ufnf2)
    #return lambdas, levnodes, revnodes, blocks, cdgs
end
```

Notice: to accommodate the style of LinearAlgebra.jl we should define:

```{julia}
"""
    ufnf(A::Matrix{T <: Number})

Obtain the UFNF of any matrix.
"""
ufnf(A) = ufnf₃(A)
```

```{julia}
A = A4obfuscated
#n_ι = 2#both empty rows and cols
#n_α = 3#only empty cols
#n_β = size(M3,1)
#n_ω = 1#only empty rows
thisUfnf3 = ufnf₃(A)
ufnf3empty= ufnf₃(MP(fill(ε,(3,3))))
ufnf3irr=ufnf(A0)
ufnf3red=ufnf(A1obfuscated)
ufnf3diag=ufnf(A2obfuscated)
A2obfuscated[ufnf3diag.beta, ufnf3diag.beta]#How to reorder using the beta
#isnothing(ufnf3.lambda[1]) && isnothing(ufnf3.lambda[2])#check for -Inf as eiv
```

## Building transitive closures depending on their UFNF structures

### For UFNF0 forms

```{julia}
"""
    tclosure(A::Matrix{T}, ufnf0::UFNF0{T}; tol=1.0e-10) where T <: Number → Matrix{T}

A function to return the transitive closure of an irreducible matrix already analysed.
Preconditions: A is square and irreducible
"""
function tclosure(A::Matrix{T}, ufnf0::UFNF0{T}; tol=1.0e-10) where T <: Number
    n = size(A,1)
    if ufnf0.λ > one(T) + tol#multiplication diverges on irreducible matrices
        return(nT(n))
    else#critical cycle length less than unity: convergence
        return A * (I(n) + A)^(n-1)
    end
end
```

```{julia}
# This basic matrix with superunit eigenvalue has a transitive closure to the top.
ufnf0 = ufnf₀(A0)
@assert tclosure(A0, ufnf0) == nT(size(A0,1))
#But if we normalize
normA0 = A0/ufnf0.λ
tclosure(normA0, ufnf₀(normA0))
```


### For UFNF1 forms

```{julia}
"""
    tclosure(A::Matrix{T}, ufnf1::UFNF1{T}; tol=1.0e-10) where T <: Number → Matrix{T}

A function to return the transitive closure of an UFNF1 form reducible matrix. 

Preconditions: A is square and UFNF1 reducible
"""
function tclosure(A::Matrix{T}, ufnf1::UFNF1{T}; tol=1.0e-10) where T <: Number
    n = size(A,1)
    # Acess strongly connected components sccs, condensation digraph cdg and components ufnf0s
    (; sccs, cdg, ufnf0s) = ufnf1
    m = length(sccs)#num of sccs
    Aplus = nB(n)#Make room for result
    Astars = Array{Matrix{T}}(undef,m)#Trclosures of the components, just in case

    # 1. Find dominance in the cdg
    #retrieve the lambdas 
    lambdas = map(u -> u.λ, ufnf0s)
    isDominated = #is component dominated by upward component
        [any(lambdas[flist] .> lambdas[i] * tol) for (i,flist) in enumerate(cdg.fadjlist)]
    #Precondition: At least one initial, non-dominated class

    # 2. Work out the evs
    #In general, use formula from eq 9 recursively, but considering saturation
    for (k,scc) in Iterators.reverse(enumerate(sccs))#The algorithm is tail-recursive
        # For dominated 
        if lambdas[k] > one(T) + tol#MP *, remember so 0 + tol 
        #if lambdas[k] > one(T)*tol
            Astars[k] = nT(length(scc))#No need to invoke tclosure
            Aplus[scc,scc] = Astars[k] #I(n) + Top(n) = Top(n)
        #elseif isDominated[k]#This is the funny case
            
        else#non-dominated, less than unit lambdas.
            Aplus[scc,scc] = tclosure(A[scc,scc], ufnf0s[k]; tol=tol)
            #Astars[k] = I(length(scc)) + Aplus[scc,scc]
            Astars[k] = rclosure(Aplus[scc,scc])
        end
        successors = reduce(union,bfs_tree(cdg,k; dir=:in).fadjlist)
        if !isempty(successors)
            succnodes = reduce(vcat,sccs[successors])
            Aplus[scc,succnodes] = 
                Astars[k] * A[scc,succnodes] * Aplus[succnodes,succnodes]
        end
    end

    #In general, use formula from eq 9 recursively, but considering saturation
    #=
    for (k,ccs) in enumerate(sccs)
        #lk = ufnf0s[k].λ
        #isDominated[k] = any(map( c -> ufnf0s[c].λ  > lk + tol, cdg.fadjlist[k]))
        if isDominated[k] || lambdas[k] > one(T)*tol
            Astars[k] = nT(length(ccs))#No need to invoke tclosure
            Aplus[ccs,ccs] = Astars[k] #I(n) + Top(n) = Top(n)
        else#non-dominated, less than unit lambdas.
            Aplus[ccs,ccs] = tclosure(A[ccs,ccs], ufnf0s[k]; tol=tol)
            Astars[k] = I(length(ccs)) + Aplus[ccs,ccs]
        end
        #visit possible domination
        #This should be done from the bottom up considering domination. 
        predecessors = reduce(union,bfs_tree(cdg,k; dir=:out).fadjlist)
        for u in predecessors#upper classes contribute to star
            Aplus[sccs[u], ccs] = 
                Astars[u] * A[sccs[u], ccs] * Astars[k] #+ Aplus[sccs[u], ccs]
        end
    end
    =#

    return Aplus
end
```

The following calculations summarize the gist of working MP right eigenvectors.
To do left eigenvectors repeat the process on the transpose matrix. 
```{julia}
A = A1
ufnf1 = ufnf₁(A)
lambdas = map(u -> u.λ, ufnf1.ufnf0s)#lambdas
#levs = Array{Array{T}}(undef,length(lambdas))
revs = Array{Array{T}}(undef,length(lambdas))
# for lambda = 0
for (i,λ) in enumerate(lambdas)
    A = A1/λ
    ufnf1 = ufnf₁(A)
    Aplus = tclosure(A, ufnf1;tol)
    evs = [Aplus[i,i] ≈ one(T) for i=1:size(Aplus,1)]
    #levs[i] = Aplus[evs,:]#FVA: not quite
    revs[i] = Aplus[:,evs]
end
ev = nT(8,1)
ev[8,1] = 0
@assert A1 * ev == ev * lambdas[4]#This is the problematic case 15/09/2025
#reduce(vcat,levs)
mrevs = reduce(hcat,revs)#matrix of right evs
multlambdas = lambdas[[1,2,2,2,3,3,4]] #multilambdas ==MP.([0, 1,1,1,2,2,-3])
#diagm creates a diagonal matrix of adequate type with diagonal the vector.
@assert A1 * mrevs == mrevs * diagm(multlambdas)#right eigen equation
# for lambda = 1
```

### For UFNF2 forms

```{julia}
"""
    tclosure(A::Matrix{T}, ufnf2::UFNF2{T}; tol=1.0e-10) where T <: Number → Matrix{T}

A function to return the transitive closure of an UFNF2 form reducible matrix. This is a
diagonal of square UFNF1 subblocks. 

Preconditions: A is square and UFNF2 reducible
"""
function tclosure(A::Matrix{T}, ufnf2::UFNF2{T}; tol=1.0e-10) where T <: Number
    n = size(A,1)
    (; wccs, cdg, ufnf1s) = ufnf2
    A2plus = nB(n)
    for (w,wcc) in enumerate(wccs)
        theNodes = reduce(vcat,wcc)
        A2plus[theNodes,theNodes] = tclosure(A[theNodes,theNodes], ufnf1s[w]; tol=tol)
    end
    return A2plus
end
```

Tests:

```{julia}
#A = A3/1.3333333333333333
A = A3
ufnf2 = ufnf₂(A)
A2plus = tclosure(A, ufnf2;tol=tol)
A2plus .== A2plus * A2plus#ERROR In dominated final classes!
```

So far debugging 16-17/09/2025, 04/09/25

### For UFNF3 forms

```{julia}
"""
    tclosure(A::Matrix{T}, ufnf3::UFNF3{T}; tol=1.0e-10) where T <: Number → Matrix{T}

A function to return the transitive closure of a reducible matrix in UFNF3.

Preconditions: A is square and reducible in UFNF3.
"""
function tclosure(A::Matrix{T}, ufnf3::UFNF3{T}; tol=1.0e-10) where T <: Number
    (; iota, alpha, beta, omega, ufnf2) = ufnf3
    #early termination: if no cycles possible: return an empty matrix.
    if isempty(beta) return nB(size(A,1)) end#empty matrix
    # invariant: !isempty(beta)
    A1plus = nB(size(A,1))#create space for the result

    # permutation p1 renders A in UFNF1, but not in UFNF2
    p1 = vcat(iota,alpha,beta,omega)
    
    # permutation p2 renders A[beta,beta] in UFNF2
    #p2 = reduce(vcat, reduce(vcat, ufnf2.wccs))
    #betap = beta[perm]#permuted beta indices

    #do most of the work: select, process, store
    #A1plus[beta,beta] = tclosure(A[beta,beta], ufnf2)#FVA: olf ufnf2 needs processing!
    A1plus[beta,beta] = tclosure(A[beta,beta], ufnf₂(A[beta,beta]))#WASTE!

    #AbetaStar = rclosure(A1plus[beta,beta])#Reflexive closure of the tclosure

    if !isempty(omega)#fill the omega columns of beta rows
        A1plus[beta,omega] = rclosure(A1plus[beta,beta]) * A[beta,omega]
    end
    # Pay no attention to iota rows or columns
    if !isempty(alpha)#fill the alpha rows
        A1plus[alpha,beta] = A[alpha,beta] * rclosure(A1plus[beta,beta])
        if !isempty(omega)#fill the omega columns of alpha rows
            A1plus[alpha,omega] = A1plus[alpha,beta] * A[beta,omega] + A[alpha,omega]
        end
    end
     return A1plus
end

```

```{julia}
lambda = MP(1)
A = A4/lambda#Checking several eigenvalues
#A = A4obfuscated#UFNF3, OK
#A = A3obfuscated#UFNF2
#A = A1obfuscated#UFNF1
#A = A0#UFNF0, OK
#A = nB(5)#empty
ufnf3 = ufnf(A)
Aplus = tclosure(A,ufnf3)
Aplus
@assert Aplus * Aplus ≈ Aplus#It is a Tclosure.
#Go over diagonal indices 
for i in filter(i -> Aplus[i,i] ≈ one(MP), 1:size(A,1))
    @assert all(Aplus * Aplus[:,i] .≈ Aplus[:,i])
end
```

### Generic primitive without the UFNF form

```{julia}
"""
    tclosure(A::Matrix{MP}) → Matrix{MP}

Transitive closure---aka Kleene's plus `A^+` of a matrix `A` over the max-plus idempotent semifield.

Result: `A^+`. This is not a syntax for it. Instead use `tclosure(A)`.

"""
function tclosure(A::Matrix{MP})
    m,n = size(A)
    m != n && n < 0 && error("Can only find trclosure on a square matrix.")
    n == 1 && return (A[n,n] > 0 ? nT(n) : A) 
    return tclosure(A,ufnf(A))
    #return tclosure_raw(A::Matrix{MP}; n=n)    
end

"""
    trclosure(A::Matrix{T}) where T <: Number → Matrix{T}

Transitive reflexive closure when the structure of the matrix is unknown.

Remember the transitive reflexive closure behaves as `A^* = In + A^+` where `In` is the max-plus identity of order n.
"""
trclosure(A) = rclosure(tclosure(A))
```

Example on the test data testing the relationships between the tclosure and the trclosure:

```{julia}
A = A0
#closures do not converge for main lambda bigger than 0.0
r = howard(sparse(A))
Anorm = A ./ r.eigenvalues[1]
n = size(Anorm,1)
tclosure(Anorm)
#In = I(n,n)#FVA: old, cumbersome mode
#In = [MP(i != j ? -Inf : 0.0)  for i in 1:n, j in 1:n]#FVA: old, cumbersome mode
@assert trclosure(Anorm) .+ eps(Float64) ≈ I(n) + tclosure(Anorm) .+ eps(Float64)
#@assert plustimes(trclosure(Anorm)) ≈ plustimes(In + tclosure(Anorm))#FVA: old, cumbersome mode
@assert tclosure(Anorm) ≈ Anorm * trclosure(Anorm)
#@assert plustimes(tclosure(Anorm)) ≈ plustimes(Anorm * trclosure(Anorm))#FVA: old, cumbersome mode
#k = 100
#A = Anorm
#Next debug mmp_mpower
B = fill(MP(2.0), (1,1)) #MP.(ones(1,1)*2)
@assert trclosure(B) == tclosure(B) == [mptop;;]#Special case!
```


## Finding the Spectrum

TODO: we have to implement the following LinearAlgebra primitives:
- `eigvals(A)`
- `eigvecs(A)`
- `Eigen` the Eigen decomposition of a matrix. 
- `eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen`

```{julia}
"""
    A type to store the results of Semiring Eigenvalue Problems in irreducible matrices with fields:

    - eivals::Array{T} the single eigenvalue of UFNF0 repeated as many times as the critical cycles.
    - leivs::Array{Matrix{T}} the left eigenvectors of the matrix, as a matrix of row vectors, coindexed with the nodes in the crictical cycles
    - reivs::Array{Matrix{T}} the right eigenvectors of the matrix, as a matrix of column vectors, coindexed with the nodes in the crictical cycles
    - ccycles::Array{Cycle} the vector of critical cycles as lists of the nodes that appear in them in the correct order. 
"""
@kwdef struct SemiEigen0{T <: Number}#FVA: cannot be expressed as type constraint e.g. where T <: Number!!!
    eivals::Array{T}#Eigenvalue repeated by the number of critical cycles
    leivs::Array{Matrix{T}}#left eigenvectors Coindexed with critical cycles
    reivs::Array{Matrix{T}}#right eigenvectors Coindexed with critical cycles 
    ccycles::Array{Cycle}#Local critical Cycles, cycles are vectors of integers
end

```

### For UFNF0

```{julia}
"""
   eigen₀_raw(Aᵢ::Matrix{MP}, n::Int; tol=1e-10) → 

Precondition: Aᵢ is , square and not of dim = 1x1 size(Aᵢ,1)=n > 1 and irreducible (e.g. not empty, single strongly connected component) 

This is only supposed to be used if in costly computations. It is better to use
eigen₀_raw(Aᵢ::Matrix{MP}; tol=1e-10) (q.v.) for most computations. 
"""
function eigen₀_raw(Aᵢ::Matrix{T}; tol=1e-10, alg="cycles") where T <: Number
    # Otherwise, 
    # 0.find the eigenvalue: 
    # a) using Howard's algorithm
    if alg == "cycles"#Using and detecting all critical cycles
        dg = Graphs.DiGraph(Aᵢ  .!= zero(T))
        #allCycles = Graphs.simplecycles(dg)#The critical cycle need a better approach. 
        allCycles::Array{Cycle} = Graphs.simplecycles_hawick_james(dg)
        weight(cc::Cycle)::T = 
            reduce(*, Aᵢ[CartesianIndex.(cycle2pairs(cc))]; init=one(T))
        avrgeCycleWeight = [length(cc) == 1 ? 
            Aᵢ[cc[1], cc[1]] : weight(cc)^(1/length(cc)) 
            for (c,cc) in enumerate(allCycles)]
        λ = maximum(avrgeCycleWeight)#The λ is maximum cycle mean
        #The critical cycles are those whose cycle mean is the λ
        ccycles::Array{Cycle} = allCycles[avrgeCycleWeight .≈ λ]

    elseif alg == "howard" && T <: MP#ensure this is only done for MP!
        r = howard(sparse(Aᵢ))
        λ = r.eigenvalues[1]#There is always at least one eigenvalue.
        # b) using the maximal cycle mean 
        # TODO: maximal cycle detection
        cycles = [r.policy]
        # 1: Normalize Aᵢ dividiendo por autovalor
        #A = Aᵢ ./ eival#Normalized matrix right MP division (unless this is the top aka Inf in Maxplus)

        # Step 2: Work out A^* = I_n + A^+
        #Aᵢstar = trclosure(A)

        #Instead of using the eigenodes detected by the Howard algorithm, detect them here: 
        #ccycles = [findall(i -> abs(Aᵢstar[i, i]) < tol, 1:n)]
    else#alternatively use the mcm
        error(" Unspecified irreducible matrix spectral algorithm")
    end
    eivals=[λ for c in eachindex(ccycles)]#pair up the λ with each critical cycle
    
    # Find the 
    Aᵢstar = trclosure(Aᵢ ./ λ)#Q.FVA: this trclosure only works for MP! Have to make it polymorphic?

    leivs = map(cc -> Aᵢstar[cc,:], ccycles)
    reivs = map(cc -> Aᵢstar[:,cc], ccycles)

    return SemiEigen0{T}(;eivals, leivs, reivs, ccycles)#, Aᵢstar[evNodes,:], Aᵢstar[:,evNodes]
end 

"""
    eigen₀(Aᵢ::Matrix{MP}; tol=1e-10) -> eival, levs, revs, ccycles
 
Finds out the UtMV form of the eigenvector theorem for an irreducible matrix. 

Precondition: `Aᵢ` is an irreducible matrix (e.g. not empty, single strongly connected component) 

Returns an UFNF0 structure: 
- `eivals`: the single eigenvalue for this matrix as many times as critical cycles repeated in an array. 
- `ccycles`: a vector of vectors of nodes where left and right eigenvectors are realised
<---
- `leivs`: left eigenvectors. Obsolete.
- `reivs`: right eigenvectors. Obsolete.
--->
Examples:
'''julia
a = 1
'''
"""
function eigen₀(Aᵢ::Matrix{T}; alg="cycles", tol=1e-10) where T <: Number
    (n,m) = size(Aᵢ)
    n == m || n == 0 | error("Can only do UFN0 for non-zero dimension square matrices.")
    #Early termination. Probably wrong if Bi = [Inf]
    n == 1 && return SemiEigen0{T}(; 
        eivals = [Aᵢ[1,1]], 
        leivs = [[one(T);;]], 
        reivs = [[one(T);;]],  
        ccycles = [[1]])
    return eigen₀_raw(Aᵢ; tol=tol)
end
```


An example on a part of the demo matrix which is irreducible:

Tests for the spectrum of irreducible matrices: 

```{julia}
##### The unary case also works with standard numbers!!!
B = fill(2.0, (1,1)) #Standard numbers
#B = MP(fill(2.0, (1,1))) #MP algebra numbers
#@assert getUFNF₀(B) == UFNF0{MP}(2.0, [[1]])#FVA there is no equality defined
#let's do the de-structuring
(;eivals, leivs, reivs, ccycles) = eigen₀(B)
#this works for order 1
@assert eivals[1] ≈ B[1,1] && ccycles  == [[1]]
@assert leivs[1] * B ≈ leivs[1] * eivals[1]
@assert B * reivs[1] ≈ reivs[1] * eivals[1]
#### The case with a non-trivial irreducible matrix.
Aᵢ=A0
(;eivals, leivs, reivs, ccycles) = eigen₀(Aᵢ)
#Aᵢnorm_star = tclosure(Aᵢ./eival)
#levs = Aᵢnorm_star[cycles[1],:]#How to obtain left evs
#revs = Aᵢnorm_star[:, cycles[1]]#How to obtain right evs
#Check left and right eigenvector properties.
#Check the left eigenvector property: we have to use approx due to calculations errors
@assert all([leivs[i] * Aᵢ ≈ leivs[i] .* λ for (i,λ) in enumerate(eivals)])#Julia is so elegant!
#@assert plustimes(levs * Aᵢ) ≈ plustimes(levs .* λᵢ)#Old cumbersome mode
#Check the right eigenvector property: we have to use approx due to calculations errors
@assert all([Aᵢ * reivs[1] ≈ reivs[1] * λ for (i,λ) in enumerate(eivals)])#product by a scalar is lifted to pointwise multiplication!
##### Using Howard's algorithm for the eival, eivs
ufnf0Howard = eigen₀(Aᵢ; alg="howard")
@assert all(eivals .≈ ufnf0Howard.eivals)
@assert all(ccycles == ufnf0Howard.ccycles) && 
    (leivs[1] ≈ ufnf0Howard.leivs[1]) && 
    (reivs[1] ≈ ufnf0Howard.reivs[1])
```

Another example with two critical cycles:

```{julia}
scc = [5,6,7]
A5 = MP(M1[scc,scc])
Aᵢ = A5
(;eivals, leivs, reivs, ccycles) = eigen₀(Aᵢ)
@assert all([leivs[i] * Aᵢ ≈ leivs[i] .* λ for (i,λ) in enumerate(eivals)])
@assert all([Aᵢ * reivs[1] ≈ reivs[1] * λ for (i,λ) in enumerate(eivals)])#product by a #Julia is so elegant!
```

### For UFNF1
The type to store the information:

```{julia}
"""
    A type to store the results of Semiring Eigenvalue Problems in UFNF1 matrices

Parameters:
"""
@kwdef struct SemiEigen1{T <: Number}
    eivals::Array{Array{T}}#Eigenvalues by wcc and scc
    leivs::Array{Array{Matrix{T}}}#Coindexed with cycles in non-empty
    reivs::Array{Array{Matrix{T}}}#Coindexed with cycles in non-empty
    ccycles::Array{Array{Cycle}}#Cycles are vectors of integers
    spectra0::Array{SemiEigen0{T}}
    ufnf::UFNF1{T}#Stores the UFNF1
end
```

The spectral function doing the analysis:

```{julia}
"""
    eigen₁(A::Matrix{T}; tol=1e-10) where T <: Number → SemiEigen1{T}

A function to find the SemiEigen1{T} decomposition of a matrix in UFNF1, that is, reducible. 

Returns: A SemiEigen1 structure 
"""
function eigen₁(Ar::Matrix{T}, ufnf1::UFNF1{T}; tol=1e-10) where T <: Number
#function eigen₁(Ar::Matrix{T}, ufnf1::Union{UFNF1{T},nothing}; tol=1e-10) where T <: Number


    #if isnothing(ufnf1) ufnf1 = ufnf₁(Ar) end
    #ufnf1 = @something(ufnf1,ufnf₁(Ar))#macro to check for existence
    (; sccs, cdg, ufnf0s) = ufnf1#FVA: wasting time, but we need Some ufnf1
    n = size(Ar,1)

    #generate the subspectra 
    #=
    spectra0 = [ eigen₀(Ar[cc,cc]; tol) for cc in sccs]

    (eivals, leivs, reivs, ccycles, spectra0) = map(
        cc -> let s = eigen₀(Ar[cc,cc]; tol)#spectrum0
            (s.eivals, s.leivs, s.reivs, s.ccycles, s)
            end,
        sccs)
    =#
    #make space for results
    nSccs = length(sccs)
    eivals = Array{Array{T}}(undef, nSccs)
    leivs = Array{Array{Matrix{T}}}(undef, nSccs)
    reivs = Array{Array{Matrix{T}}}(undef, nSccs)
    ccycles = Array{Array{Cycle}}(undef, nSccs)
    spectra0 = Array{SemiEigen0{T}}(undef, nSccs)
    uniqueEvals = Array{T}(undef, nSccs)#Gather the unique eigenvalues

    #build isolated results
    for (s,cc) in enumerate(sccs)
        @assert cc == ufnf1.ufnf0s[s].nodes#Change this to tests
        let sp0  = eigen₀(Ar[cc,cc]; tol=tol)
            #This is too simple: does not take into consideration:
         # - change of name of nodes
         # - condensation digraph order
            spectra0[s] = sp0#OK
            eivals[s] = sp0.eivals#OK
            uniqueEvals[s] = eivals[s][1]
            #TODO: take into consideracion cdg! and eivals
            leivs[s] = sp0.leivs#Need extension.
            reivs[s] = sp0.reivs#Need extension.
            ccycles[s] = map(cycle -> cc[cycle], sp0.ccycles)#Translating local cycles
        end 
    end

    #next visit the condensation digraph in order to see who is overshadowed!
    # @assert: uniqueEvals, cdg, sccs and closureCdg are co-indexed
    closureCdg = transitiveclosure(cdg)#transitive closure of condensation digraph
    for (s,cc) in enumerate(sccs)
        theseReivs = Array{Matrix{T}}(undef, length(leivs[s]))
        shaders = reduce(vcat, closureCdg.fadjlist[s] ∪ [s])#Upstream critical classes
        if all(uniqueEvals[shaders[1]] .<= uniqueEvals[s])#nonshaded class
            nodes = reduce(vcat, sccs[shaders])
            Astar = tclosure(Ar[nodes,nodes]/uniqueEvals[s])#Does not produce what expecteds
        else
            #just accumulate the top [0, [0;;]*[7, 0, 0]* trclosure(Ar[cc,cc]/1)
            #trclosure(Ar[[1], [1]]/1) * (Ar[[1],cc]/1) * tclosure(Ar[cc,cc]/1)#is correct
            #tclosure(Ar[nodes,nodes]/1)
        end
        for (k,ccycle) in enumerate(ccycles[s])#k coindexed with reivs of distinct cycles
            theseReivs[k] = [zero(T) for i in 1:n,j in 1:length(ccycle)]
            #theseReivs[k] = [i ∈ ccycle ? reivs[s][k] : zero(T) for i in 1:n,j in 1:length(ccycle)]
            theseReivs[k][cc] = reivs[s][k]
            @assert Ar * theseReivs[k] ≈ uniqueEvals[s]*theseReivs[k]
        end
    end

    #This is unfinished as yet!
    return SemiEigen1{T}(; eivals, leivs, reivs, ccycles, spectra0,  ufnf=ufnf1)
end
```

##SO FAR 21/07/2025 including UFNF constructors, and independent of base type 

```{julia}
Ar = A1#obfuscated
T = MP
#ufnf1::Union{UFNF1{T}, Nothing} = nothing
ufnf1 = ufnf₁(Ar)
s = 2; cc = sccs[2]
#(;eivals, leivs, reivs, ccycles, spectra0, ufnf) = 
eigen1 = eigen₁(Ar,ufnf1)
#TODO: check the eigenector equations
```

### For UFNF2

The following type is common for UFNF2{T} and UFNF3{T}

```{julia}
"""
    A type to store the results of Semiring Eigenvalue Problems in general matrices.

This type considers both:
- empty matrices have a single SemiEigen1 with the null spectrum
- completely full matrices, have a list of spectra1
- matrices with null rows and/or cols, have both the previous components, with the null spectra stuck at the beginning of the list.
"""
@kwdef struct SemiEigen{T <: Number}
    eivals::Array{Array{Array{T}}}#Eigenvalues by wcc and scc
    leivs::Array{Array{Array{Matrix{T}}}}#Coindexed with cycles in non-empty
    reivs::Array{Array{Array{Matrix{T}}}}#Coindexed with cycles in non-empty
    ccycles::Array{Array{Array{Cycle}}}#Cycles are vectors of integers
    spectra1::Array{SemiEigen1{T}}# A list of spectra of type 1
    ufnf::Union{UFNF{T}, Nothing}#Stores the UFNF2 of the matrix in the non-null rows and cols
end
```

Dealing with UFNF2{T} that is, lists of `UFNF1{T}` forms. 

```{julia}
"""
    eigen₂(A::Matrix{T}; tol=1e-10) where T <: Number → 

A function to find the SemiEigen{T} decomposition of a matrix in UFNF2.
"""
function eigen₂(Ad::Matrix{T}, ufnf2::UFNF2{T}; tol=1e-10) where T <: Number
    #deconstruct the UFNF2 structure
    (; wccs, cdg, ufnf1s) = ufnf2#get the weakly connected components and their condensation digraphs and ufnf1's to pass along to. 
    n = size(Ad,1)#once we have the ufnf2 we know it is squared.

    # Initialisation of results
    nWccs = length(wccs)
    eivals = Array{Array{Array{T}}}(undef, nWccs)
    leivs = Array{Array{Array{Matrix{T}}}}(undef, nWccs) 
    reivs = Array{Array{Array{Matrix{T}}}}(undef, nWccs)
    ccycles = Array{Array{Array{Cycle}}}(undef, nWccs)
    spectra1 = Array{SemiEigen1{T}}(undef, nWccs)
    nodes = Array{Array{Int}}(undef, nWccs)#Sets of nodes, not cycles

    # Going over the weakly connected components to put together results
    for (w,wcc) in enumerate(wccs)
        nodes[w] = reduce(vcat, wcc)#flatten out the list of nodes of a wcc
        eigen1 = eigen₁(Ad[nodes[w],nodes[w]], ufnf1s[w]; tol=tol)#find out spectrum1
        eivals[w] = eigen1.eivals#store the same eigenvalues
        #TODO: translate the eigenvectors
        #regrow the left and righ eigenvalues
        #Start recoding from here.
        #=
        theseLeivs = 
        leivs[w] = theseLeivs
        eigen1.leivs#put column reivs and translate!
        theseReivs = [[(i != j ? zero(T) : one(T)) for i in 1:n, j in allZeroCols]]]
        eigen1.reivs
        reivs[w] = theseReivs
        =#
        leivs[w] = eigen1.leivs#Error!
        reivs[w] = eigen1.reivs#Error!
        # Translate the cycles
        ccycles[w] = 
            map(lcycles -> map(cycle -> nodes[w][cycle], lcycles), eigen1.ccycles)
        spectra1[w] = #eigen1#Better to create the translated version
            SemiEigen1{T}(; eivals=eivals[w], leivs=leivs[w], reivs=reivs[w], 
                            ccycles=ccycles[w], 
                            spectra0=eigen1.spectra0, ufnf=eigen1.ufnf)
    end

    return SemiEigen{T}(; eivals, leivs, reivs, ccycles, spectra1, ufnf=ufnf2)
end
```

```{julia}
Ad = A2obfuscated
T = MP
#ufnf1::Union{UFNF1{T}, Nothing} = nothing
ufnf2 = ufnf₂(Ad)
#w = 2; wcc = wccs[w]
#(;eivals, leivs, reivs, ccycles, spectra0, ufnf) = 
s2 = eigen₂(Ad,ufnf2)
#TODO: check the eigenector equations
#@assert s3.leivs[1][1][1] * A ≈ s3.eivals[1][1][1] * s3.leivs[1][1][1]
#@assert A * s3.reivs[1][1][1] ≈ s3.reivs[1][1][1] * s3.eivals[1][1][1]
```

A more complex example:

```{julia}
Ad = A3obfuscated#three-component UFNF2
ufnf2 = ufnf₂(Ad)
eigen2 = eigen₂(Ad,ufnf2)
```

### For UFNF3

For UFNF3: 
- obtain the `ε` eigenvectors, if existing.

```{julia}
"""
    eigen₃(A::Matrix{T}; tol=1e-10) where T <: Number →

A function to find the Eigen factorization of a matrix given by:
    - values::   Its proper spectrum, the eigenvalues
    - lvectors:: left eigenvectors
    - rvectors:: right eigenvectors
    - cycles:: maximum weight cycles generating the eigenvalues
    - ufnf::UFNF{T} its Upper Frobenius Normal Form.
""" 
function eigen₃(A::Matrix{T}; tol=1e-10) where T <: Number
    (; iota, alpha, beta, omega, ufnf2) = ufnf₃(A)#checks squareness, deals with corner cases.
    n = size(A,1)

    #This might be a "dummy" UFNF3, UFNF2, UFNF1 up until an UFNF0
    # 1) No empty lines: reduce to UFNF2
    beta ⊇ 1:n && return eigen₂(A, ufnf2; tol=tol)#bypass all other constructions

    #Some empty lines: encode empty rows in first eigenvalue empty cols in second
    zeroLambdas::Array{Array{T}} = [[zero(T)], [zero(T)]]#consider left and right eivals as wccs
    allZeroRows = sort(iota ∪ omega)
    allZeroCols = sort(iota ∪ alpha)
    if isempty(allZeroRows) 
        zeroLambdas[1] = []#encode empty rows einvals[1][1][1]
    else
        println("Zero rows:", allZeroRows)
    end 
    if isempty(allZeroCols) 
        zeroLambdas[2] = []#encode empty cols einvals[1][2][1]
    else
        println("Zero cols:", allZeroCols)
    end

    #and generate the adequate left (row) eigenvectors in their correct multiplicities: these are sorted!
    zeroLeivs::Array{Array{Matrix{MP}}} = 
        [[[(i != j ? zero(T) : one(T)) for i in allZeroRows, j in 1:n]]]
    #...and generate the adequate right (col) eigenvectors
    zeroReivs::Array{Array{Matrix{MP}}} = 
        [[[(i != j ? zero(T) : one(T)) for i in 1:n, j in allZeroCols]]]

    # 2) Empty matrix: just return the zero eigenvalue and a free generator of boolean lattices
    #zeroLeivs = [[[(i != j ? zero(T) : one(T)) for i in 1:n, j in 1:n]]]
    #zeroReivs = [[[(i != j ? zero(T) : one(T)) for i in 1:n, j in 1:n]]]
    isempty(beta) && 
        return SemiEigen{T}(; 
            eivals = [zeroLambdas], 
            leivs = [zeroLeivs],
            reivs = [zeroReivs],
            ccycles = [],
            spectra1 = [], 
            ufnf = ufnf2)#In this case, this is `nothing`

    # This should be passed onto tests!
    #@assert if zeroLambdas[1] == zero(T), there are zero(T) left eigenvectors
    @assert ([zeroLambdas][1][1][1] == zero(T)) && 
        (zeroLeivs[1][1] * A ≈ zero(T) * zeroLeivs[1][1])
    #@assert if zeroLambdas[2] == zero(T), then there are zero(T) right eigenvectors
    @assert [zeroLambdas][1][2][1] == zero(T) && A * zeroReivs[1][1]  ≈ zero(T) * zeroReivs[1][1]

    #  3) Some empty lines, some non-empty lines
    # If there are empty lines, detect whether they are cols and/or rows
    #Next calculate the spectrum of the UFNF2 part and mix
    #precondition, A[beta, beta] is already in 
    e2 = eigen₂(A[beta, beta], ufnf2; tol=tol)#This is also a SemiEigen

    eivals = vcat([zeroLambdas], e2.eivals)
    #TODO: re-conform the eigenvectors
    leivs = vcat([zeroLeivs], e2.leivs)
    reivs = vcat([zeroReivs], e2.reivs)
    #re-express the cycles in the nodes of beta
    ccycles = #e2.ccycles#Perhaps we should add an empty component here?
        map(wcycles ->
                map(scycles -> map(cycle -> beta[cycle], scycles), 
                wcycles),
        e2.ccycles)
    return SemiEigen{T}(; eivals, leivs, reivs, ccycles, 
                        spectra1=e2.spectra1, ufnf=ufnf2)
end
function eigen(A::Matrix{T}; tol=1e-10) where T <: Number 
    return eigen₃(A; tol=tol)
end
```

```{julia}
#[(i != j ? zero(T) : one(T)) for i in 1:n, j in 1:n]
#spectrumEmpty = eigen₃(A)
A = A4obfuscated#Generic UFNF3: Error on processing whole spectru,
A = A3obfuscated#three wccs component UFNF2: ERROR on levs, revs lengths
#A = A1obfuscated#four sccs component UFNF1: ERROR on levs, revs lengths
#A = A0#Simple but non-trivial UFNF0if the first. OK
#A = fill(ε,(3,3))#test for empty matrices.OK
ufnf3 = ufnf₃(A)
s3 = eigen₃(A)
if s3.eivals[1] == [[-Inf],[-Inf]]#empty matrix: check different leivs and reivs
    #This is actually more complicated since there can be empty rows or columns or none, and this is signaled by the presence of the bottom eigenvalue up front in s3.leivs[1]
    @assert s3.leivs[1][1][1] * A ≈ s3.eivals[1][1][1] * s3.leivs[1][1][1]
    @assert A * s3.reivs[1][1][1] ≈ s3.reivs[1][1][1] * s3.eivals[1][1][1]
else
    for k=1:length(s3.eivals)
        for l=1:length(s3.eivals[k])
            for m=1:length(s3.eivals[k][l])
                @assert s3.leivs[k][l][m] * A ≈ s3.eivals[k][l][m] * s3.leivs[k][l][m]
                @assert A * s3.reivs[k][l][m] ≈ s3.reivs[k][l][m] * s3.eivals[k][l][m]
            end
        end
    end
end
```

```{julia}
A = A4obsolete 
eigenf = eigen₃(A)
```

The following cell tries to build a function to obtain the levs, revs and the spectrum for any possible configuration, also following Julia's way.
```{julia}
"""
    eigvecs

A function to obtain the eigenvectors of a tropical matrix.
"""
function eigvecs(A,uFNF3::Eigen3())
    n = size(A,1)
    b = length(blocks)
    reigvecs = Array{Array{Matrix{MP}}}(undef, 4)
    leigvecs = Array{Array{Matrix{MP}}}(undef, 4)
    allZeroCols = [iota ; alpha]
    allZeroRows = [iota ; omega]
    finiteLambdaStart = 1
if lambdas[finiteLambdaStart][1] == ε#ε
    finiteLambdaStart = min(2,b)
    revsε =  fill(ε,(n,length(allZeroCols)))
    levsε =  fill(ε,(length(allZeroRows), n))
    for i=1:length(allZeroCols)
        revsε[allZeroCols[i],i] = 0.0
    end
    for j=1:length(allZeroRows)
        levsε[j,allZeroRows[j]] = 0.0
    end
    @assert A * revsε == revsε * ε
    @assert levsε * A == levsε * ε
    reigvecs[1] = [revsε]
    leigvecs[1] = [levsε]
end
#Let's do the rest of the co-indexed proper spectrum and blocks
for w = finiteLambdaStart:b
    revs =
    levs =
    reigvecs[1] = [revsε]
    leigvecs[1] = [levsε]
end
```

## Data from C.elegans

REad the functional connectome data for C. elegans interneurons from a CSV file and convert it to a matrix of Semifields.
```{julia}
# Leer el archivo CSV
df = CSV.read(
        datadir("exp_raw","functional_connectivity_interneurons.csv"), 
        DataFrame)
#TODO: FVA. Explore the dataset. rows? Cols?

# Nombres de neuronas
neuron_labels = Vector{String}(df[:, 1]);  # Asume que la primera columna del DataFrame contiene los nombres

# Reemplazar valores missing con -Inf
df_filled = coalesce.(df, -Inf);

# Convertir el DataFrame en una matriz numérica y la transpone con '
mat = Matrix(df_filled[:, 2:end])'  # la primera columna son las etiquetas

# Asegurar que está en el tipo correcto
mat = convert(Array{Float64}, mat)

# Reconstruimos el df transpuesto
# Crear el DataFrame con los datos transpuestos
df_transposed = DataFrame(mat, copy(neuron_labels))  # Usa neuron_labels como nombres de columna

# Añadir la columna con los nombres de fila
df_transposed = insertcols(df_transposed, 1, :Neuron => neuron_labels)

#Cambiar los 0s por -Inf
#mat_mp_ready = map(x -> x == 0.0 ? -Inf : x, mat)
B = MP.(mat);
# Imprime la matriz MP completa sin truncar
show(stdout, "text/plain", B)
```

Now do a test check:

```{julia}
neuronas = ["AIBL", "RIAR", "RIAL"]
row_idxs = findall(n -> n in neuronas, neuron_labels)
test = df[row_idxs, neuronas]
show(stdout, "text/plain", test)
show(stdout, "text/plain",B[row_idxs,row_idxs])#FVA: not in UFNF0
```
# Test Case 1: Working out the right eigenvalues

Find the strongly connected components by their matrices.
```{julia}
"""
    extract_all_strong_components → submatrices, components, node_to_component, condensation

- condensation: condensation digraph

A primitive to extract all strong components from a matrix in UFNF2 format
with no zero lines. 

This returns the condensation digraph of the matrix, 

TODO: Change to entries in a semifield or CSemifield. 
"""
function extract_all_strong_components(B_mp::Matrix{MP})
    # FVA: this is the digraph associated to the matrix.
    n = size(B_mp, 1) 
    @assert n == size(B_mp, 2)#FVA: only valid for square matrices, in principle!
    #G = Graphs.DiGraph(n)    
    #You have to start using comprehensions instead of for loops
    #[add_edge!(G,i,j) for i = 1:n, j=1:n if B_mp[i, j] != MP(-Inf)]#This needs to be changed to the bottom of the semifield.
    #FVA: you can cleanly create the digraph from an interator on the edges
    G2 = Graphs.DiGraph(Edge.([(i,j) for i = 1:n, j=1:n if B_mp[i, j] != MP(-Inf)]))#Comprehension to create the edges of the graph.
    G = Graphs.DiGraph(B_mp .!= MP(-Inf))#FVA: Even easier, you can use the matrix directly to create the graph.
    #FVA: why a {59, 193} directed simple Int64 graph, and not a Bool graph. A: because that would be a non-generalisable encoding of link weights! Anyway, it should be either ones or tops, but the latter are difficult to operate with 
    @assert G == G2 #FVA: this is a test to see if the graph is well built.
    #for i in 1:n
    #    for j in 1:n
    #        if B_mp[i, j] != MP(-Inf)
    #            add_edge!(G, i, j)
    #        end
    #    end
    #end

    #This is building the direct and inverse dictionaries of nodes and components. 
    # 1. this is the component => node dictionary.
    components = Graphs.strongly_connected_components(G)

    # FVA: some constructors are immediate!
    #node_to_component = Dict(enumerate(components))
    #@assert length(components) == length(node_to_component)
    # Creamos el mapeo manualmente
    #node_to_component = Dict{Int, Int}()
    node_to_component = zeros(Int64,1,n) 
    #FVA: since every node belongs to just one component, it is better to use a vector
    #node_to_component = zeros(Int, n)#make space
    # Las submatrices de componentes
    submatrices = Matrix{MP}[]
    #=
    component_nodes = Vector{Int}[]
    for nodes in node_groups
        push!(submatrices, B_mp[nodes, nodes])
        push!(component_nodes, nodes)
    end
    =#
    for (comp_id, comp_nodes) in enumerate(components)
        push!(submatrices, B_mp[comp_nodes, comp_nodes])
        for node in comp_nodes
            node_to_component[node] = comp_id
        end
    end
    @assert length.(components) == map(m -> size(m,1), (submatrices))
    @assert all()

    
    # node_groups: lista de nodos por componente
    # FVA: this is a list of lists, where each sublist contains the nodes in a component.
    # FVA: but this seems to be just the list of nodes by component, which is exactly `components
    #=
    num_components = length(components)
    node_groups = [Int[] for _ in 1:num_components]
    for (node, comp_id) in sort(collect(node_to_component))
        push!(node_groups[comp_id], node)
    end
    =#


    # Condensed graph: it is better to give it the clue of the components
    #cond = Graphs.condensation(G)
    cond = Graphs.condensation(G, components)#If you have the components, you can build the condensed matrix directly.

    #return submatrices, component_nodes, cond, node_groups
    return submatrices, components, node_to_component, cond
end
```

Use this primitive to extract all strong components from the matrix `B_mp`:

```{julia}
submatrices, components, node_to_component, cond = extract_all_strong_components(B_mp)
# Print the number of components
println("Number of components: ", length(components))
# Print the nodes in each component
for (i, nodes) in enumerate(components)
    println("Component $i: ", join(nodes, ", "))
end
# Print the condensed graph
println("Condensed graph: ", cond)
# Print the submatrices
for (i, submat) in enumerate(submatrices)
    println("Submatrix for component $i:\n", submat)
end
# Print the node groups
for (i, nodes) in enumerate(node_to_component)
    println("Node group $i: ", join(nodes, ", "))
end
```

A better principled visualisation after Emma:
```{julia}
for (i, (B_sub, nodes)) in enumerate(zip(submatrices, components))
    println("==== Componente $i ====")
    println("Nodos:")
    println(nodes)
    println("\nSubmatriz:")
    # Imprime la matriz MP completa sin truncar
    show(stdout, "text/plain", B_sub)
    println("\n\n---------------------------\n")
end
```

## Calculo de autovalores

Work out the eigenvalues

```{julia}
#FVA: dimension this better
eigenvalues = MP.(zeros(Float64,n,1))
for (i, B_sub) in enumerate(submatrices)
    r = howard(sparse(B_sub)) 
    lambda = r.eigenvalues  
    println("Autovalor max-plus de componente $i: ", MP(lambda[1]))
    #push!(eigenvalues, MP(lambda[1]))
    eigenvalues[i] = MP(lambda[1])
end
```

Find out the eigenvectors for irreducible matrices:

```{julia}
"""
all_eigenvectors(Au::Matrix{MP}, λ ::MP;  tol=1e-10) → evPositions, Anstar

A primitive to work out the left (rows) and right (column) eigenvalues of an irreducible matrix
by looking at the elements of the diagonal of the TSR closure of the normalized matrix.
- A: square MP matrix. 
- λ: its eigenvector. 

We return the nodes rather than the actual vectors. 
- evPositions: positions of the eigenvectors in 1:n with n = size(A,1)
- Anstar: star of normalized input matrix A

TODO: this algorithm is formally identical for MinPlus analysis, eg. polymorphic. 
"""
function allEigenvectors(Aᵢ::Matrix{MP}, λᵢ::MP; tol=1e-10)
    n = size(Aᵢ, 1)
    I_n = [i == j ? MP(0.0) : MP(-Inf) for i in 1:n, j in 1:n]#FVA: uses too much space?
    n == 1 && return n, I_n#Early termination. Probably wrong if Bi = [-Inf]

    # Paso 1: Normalizar B_i dividiendo por autovalor (max-plus: restar)
    A = Aᵢ ./ λᵢ#Normalized matrix right MP division (unless this is the top aka Inf in Maxplus)

    # Paso 2: Calcular A^+ = A + A^2 + ... until convergence
    # FVA: actually by idempotency of addition this only needs to be done at most until Bp^n
    # FVA: this is the naive, iterative algorithm. 
    # FVA: it can be improved by doing a doubling algorithm, see in old Matlab code. 
    Ai = deepcopy(A)#Will store the latest A^i. Here i=1
    Aplus = MP[-Inf] .+ Ai #MP[-Inf for _ in 1:n, _ in 1:n]#Zero max-plus matrix. Will accumulate
    for i in 2:n#FVA: at least goes over this once, since n==1 is taken care of.
        Ai = Ai * A#FVA: maxplus addition The copy is done in the first update
        Aplus = Aplus + Ai#FVA: maxplus addition
    end
    # Step 3: Work out A^* = I_n + A^+
    #FVA: for A^* we just add the identity to A^+
    Astar = Aplus + I_n

    #ERF
    #=
    A_star = deepcopy(A)
    A_prev = MP[-Inf for _ in 1:n, _ in 1:n]
    A_star .= max.(A_star, I_mp)  # A_star = max(A_star, I)
    max_iter = 100
    iter = 0
    while !isequal(A_star, A_prev) && iter < max_iter
        iter += 1
        A_prev = deepcopy(A_star)
        A_star = max.(A_star, A_prev * Bp)
    end
    =#

    # Paso 3: Detectar posiciones con valor cercano a 0 en la diagonal
    evPositions = findall(i -> abs(Astar[i, i]) < tol, 1:n)

    # Paso 4: Autovectores por la izquierda: filas en posiciones relevantes
    #left_eigenvectors = [Astar[:, i] for i in evPositions]

    # Paso 5: Autovectores por la derecha: columnas en posiciones relevantes
    #right_eigenvectors = [Astar[i, :] for i in evPositions]

    #FVA: it were better to return the index over the A_star
    #return left_eigenvectors, right_eigenvectors, Astar
    return evPositions,Astar
end
```

Check with the matrices from classes 8(2 nodes) and 9(24 columns):

```{julia}
begin
    i = 1
    evPositions, Astar = allEigenvectors(submatrices[i], eigenvalues[i])
    i = 8
    evPositions, Astar = allEigenvectors(submatrices[i], eigenvalues[i])
    i = 9
    evPositions, Astar = allEigenvectors(submatrices[i], eigenvalues[i])
end
```

## Upper Frobenius Normal Form (UFNF)

```{julia}
"""
    getUFNF(B::Matrix{MP}, node_groups::Vector{Vector{Int}}, cond::DiGraph) → 

A primitive to obtain the permutation that transforms a given possibly reducible matrix into 
upper Frobenius Normal Form (UFNF). This normal forms favours that starting classes in the 
condensed digraph appear to the upper left and final classes to the lower right. This would indeed be the case for a single Strongly Connected Component (SCC).

The algorithm proceeds in the hierarchy of normal forms, except it supposes there are no 
empty rows or columns (so UFNF3 is not needed.)

Check wrt "The Spectra of Reducible Matrices over Completed Commutative Idempotent Semiﬁelds and their Spectral Lattices", by Valverde-Albacete and Peláez Moreno

"""
function getUFNF(B::Matrix{MP}, 
    node_groups::Vector{Vector{Int}}, 
    cond::DiGraph, 
    neuron_labels::Vector{String})

    # UFNF2: diagonal matrix of SCCs of symmetrical graph. 
    num_sccs = length(node_groups)
    group_indices = collect(1:num_sccs)

    # Paso 1: obtener CGCs como componentes débilmente conectadas del DAG cond
    undirected_cond = Graph(cond)  # convierte el DAG en grafo no dirigido
    cgc_components = connected_components(undirected_cond)  # cada CGC es un conjunto de SCCs

    # Paso 2: ordenar CGCs por número de SCCs (de menor a mayor)
    sorted_cgcs = sort(cgc_components, by = cgc -> length(cgc))

    # Paso 3: obtener orden topológico global de las SCCs
    global_topo = topological_sort(cond)
    topo_pos = Dict(scc => findfirst(isequal(scc), global_topo) for scc in group_indices)

    # Paso 4: ordenar SCCs dentro de cada CGC por orden topológico
    ordered_sccs = Vector{Int}()
    for cgc in sorted_cgcs
        ordered = sort(cgc, by = scc -> topo_pos[scc])
        append!(ordered_sccs, ordered)
    end

    # Paso 5: expandimos a nodos reales
    ordered_nodes = reduce(vcat, node_groups[ordered_sccs])
    ordered_labels = neuron_labels[ordered_nodes]
    B_frobenius = B[ordered_nodes, ordered_nodes]

    return B_frobenius, ordered_nodes, ordered_labels
end
```

